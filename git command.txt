

****************************************
***              git                 ***
****************************************

========================================
安装成功之后,进行设置
git config --global user.name "Your Name"
git config --global user.email "你的邮箱"

查看是否设置成功
git config --global user.email 

本地Git仓库和GitHub仓库之间的传输是通过SSH加密的
所以,需要创建ssh key .在用户主目录下，看看有没有.ssh目录
如果没有, 则用下列命令进行创建
ssh-keygen -t rsa -C 你的邮箱



========================================
查看所有分支:(当前分支前, 会标一个*号)
	git branch (只有完成第一次提交之后, 才能看到master分支)
	git branch -a 查看所有分支：包括远程分支

创建分支:
	git branch  分支名字

切换分支:
	git checkout 分支名字(容易和 检出混淆,不推荐)
	git switch  分支名字

创建并切换分支:
	git checkout -b 分支名字 (容易和撤销修改混淆,不推荐)
	git switch -c 分支名字 (-c 即 create)

删除分支:
	git branch -d 分支名字
	git branch -D 分支名字 (强行删除一个没有被合并到master上的分支)


合并 '其他某分支' 到当前分支 (两种模式, 默认第一种)：
	1. Fast forward模式: 这种模式下，删除分支后，会丢掉分支信息,看不出来曾经做过合并
		git merge 其他某分支名字

	2. 普通模式:	合并后的历史有分支，能看出来曾经做过合并
		git merge --no-ff -m "merge with no-ff" 其他某分支名字
		(因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去)

	tips: 从本质上说git分支都是个名字，没有主次之分,所以谁合并谁，过程都是一样的。


其他分支：
	git clone/ git pull后，默认情况下，只能看到本地的master分支
	
	1.直接建立链接
		想在dev分支上开发，就必须创建远程origin/dev分支到本地
		git checkout -b dev origin/dev
		git checkout -b 本地分支名 origin/远程分支名

	2.本地新建了一个dev，代码写了很多了，才发现是基于origin/master创建的dev
	直接 git push origin dev 推送的话，会推送到master
	
	这个本地dev如何和远程dev关联呢？
	git branch --set-upstream-to=origin/dev dev
	git branch --set-upstream-to=origin/远程分支名 本地分支名
	提示信息为：
	Branch 'devv' set up to track remote branch 'dev' from 'origin'.

	再推送即可






********
	提示：一定要学会看分支合并图

========================================
初始化(新建仓库):
	git init	(目录下多出 .git 文件夹)（并且自动创建第一个分支 master）

	----工作区--------			----暂存区--------		----某分支--------
	|				|			|				|		|	版本1		|
	|写代码的地方		| add		|				| commit|	版本2		|
	|代码文件		| ====>		|				| ====>	|	版本3		|
	|				|			|				|		|				|
	|				| restore	|				|		|				|
	|				| --stage	|				|		|				|
	|				| <====		|				|		|				|
	|				|			|				|		|				|
	|				| diff		|				|		|				|
	|				| <==>		|				|		|				|
	|				|			|				|		|				|
	-----------------			-----------------		-----------------



创建文件, 并进行编辑后,
查看所有仓库下的文件编辑状态:
	git status:
		untracked file: 新创建的,	在工作区 (需要手动提交到暂存区)
		modified(红色): 被修改,		在工作区 (需要手动提交到暂存区)
		modified(绿色): 被修改 				(已经提交到暂存区)



|将工作区的文件添加到 暂存区:
|	git add 文件名 (添加指定的 修改过的文件)
|	git add .	  (添加全部 修改过的文件)
|
|将暂存区的修改, 撤回到工作区:
|	git restore --staged 文件名  
|
|撤销修改:
|		工作区的文件: 被修改后，还未add到暂存区，(也就是说，仅仅在工作区玩儿)
|		git restore 文件名 （相当于 ctrl + Z）
|			也可以用git checkout -- file，其实是 检出版本库里的版本,替换工作区的版本
|			（命令中没有 -- ，就是切换分支，容易混淆，不推荐）


将暂存区的文件 进行提交
	git commit :					(会进入到vim, 用来编辑提交信息)
	git commit -m "first commit" :	提交+填写提交信息,一次完成
	(********** 提交的是更改, 不是文件 **********)

查看修改内容:
	git diff 文件名		：工作区的修改 和 暂存的修改 		的差异
	git diff HEAD 文件名	：工作区的修改 和 版本库的最新版本	的差异



删除(被添加到版本库中的)文件后:
	1.如果你确实要从版本库中删除该文件,就先rm (相当于add到暂存区), 再提交
		git rm/add 文件名; git commit
	2.如果你手滑误删,就从版本库中检出
		git checkout -- test.txt



========================================
查看日志(无法看到回滚记录):
	git log 					(完整模式)
	git log  --pretty=oneline	(一行模式+完整版本号)
	git log  --pretty=oneline --abbrev-commit (一行模式+精简版本号)
	git log -数字 	(查看最近n次提交)

查看日志(可以看到回滚记录):
	git reflog

看到分支合并图:
	git log --graph
	git log --graph --pretty=oneline
	git log --graph --pretty=oneline --abbrev-commit



========================================
回滚某分支上的版本:
	(HEAD 指向的版本，就是当前版本)
	git reset --hard HEAD~1 	回滚上1个
	git reset --hard HEAD~2 	回滚上2个
	git reset --hard HEAD~100 	回滚上100个
	git reset --hard 1094adb 	回滚到指定版本



========================================
bug分支
	当前有dev分支和master分支
	dev分支开发了一半, 不能提交, mater出现了一个bug,需要先修复;
	所以,需要先把dev分支储藏起来:
		git stash
	stash后, 工作区就是一个干净的dev(和'刚从master上创建dev'时一样)
	假如需要在master上修复bug,就从master上创建临时分支: fixbug
	修复完后, 提交 ,返回一个提交号码:比如 4c805e2 *****请记住返回的提交号码
	(然后切换到master, 删除fixbug分支)

	再回到dev上继续开发;
	在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，
	所以，这个bug其实在当前dev分支上也存在。

	那怎么在dev分支上修复同样的bug？
		git cherry-pick 4c805e2 (刚刚的提交号码)
	然后查看刚刚的工作现场:
		git stash list
	恢复工作现场:
		1. git stash apply(恢复) + git stash drop(删除stash内容)
		2. git stash pop (恢复+删除)



========================================
配置别名: (有--global为全局, 否则为当前仓库)
	git config --global alias.st status (告诉Git，以后st就表示status：)

参考配置-用友好的形式查看commit
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"

配置全局别名后,想撤销:
	去用户家目录下, 修改.gitconfig 文件即可
配置局部别名后,想撤销:
	去仓库下, 修改 .git/config 文件即可





========================================
创建标签:
	git tag v1.0			(最新提交版本)
	git tag v0.9 f52c633	(指定提交版本)
	git tag -a v0.9 -m '说明文字' f52c633 (-a指定标签名，-m指定说明文字)

查看标签列表:
	git tag (标签不是按时间顺序列出，而是按字母排序的)

查看标签信息:
	git show 标签名

删除标签(本地):
	git tag -d 标签名

推送标签到远程:
	git push origin 标签名	(推送指定)
	git push origin --tags (推送全部)

删除标签(远程): 先本地, 再推送删除到远程;(直接删远程也是可以的)
	git tag -d v0.9
	git push origin :refs/tags/v0.9



========================================
忽略特殊文件,GitHub已经为我们准备了各种配置文件
	https://github.com/github/gitignore





****************************************
***              gitHub              ***
****************************************

========================================
1.先有本地库，后有远程库的时候，如何关联远程库。
	1.1 在本地仓库下运行下列命令，把本地库与远程库关联：
		github 页面会有命令，直接拷贝即可（ssh协议最快，推荐使用）。这里不列出
		添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的


	1.2 把本地库的当前分支master的所有内容推送到远程库上：
		git push -u origin master

		(由于远程库是空的，我们第一次推送master分支时，
		加上了-u参数，Git不但会把本地的master分支内容，推送到远程新的master分支，
		还会把本地的master分支和远程的master分支关联起来，以后的推送或者拉取时就可以简化命令)

		从现在起，只要本地作了提交，就可以通过命令
		git push origin master
		把本地master分支的最新修改推送至GitHub,现在，你就拥有了真正的分布式版本库

查看远程库信息:
	git remote
	git remote -v (显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。)


推送分支,命令为 git push (远程库名字) 要推送的分支:
	git push origin master
	git push origin dev



========================================
2.先有远程库，再克隆远程库
	2.1 在github上创建一个库（记得☑️生成 readme.md 选项）
	2.2 点击"clone or download"按钮,生成项目地址链接(https/ssh（最快） 可选)
		git clone 项目地址链接











